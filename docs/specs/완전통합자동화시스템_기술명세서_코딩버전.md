# 🔧 완전 통합 자동화 시스템 - 기술 명세서 (코딩 버전)

> **작성일**: 2024년 9월 16일
> **목적**: 개발자를 위한 상세 기술 사양 및 구현 가이드
> **대상**: 시스템 복원/개발 시 참고용

---

## 🏗️ **시스템 아키텍처**

### **📊 전체 구조도**
```
┌─────────────────────────────────────────────┐
│                 GUI Layer                   │
├─────────────────────────────────────────────┤
│              Business Logic                 │
├─────────────────────────────────────────────┤
│           External Integrations             │
├─────────────────────────────────────────────┤
│              Data Storage                   │
└─────────────────────────────────────────────┘
```

### **🔗 모듈 의존성**
```python
ultimate_automation_system.py
├── core.config
├── llm.gemini_client
├── compose.composer
├── pyautogui, pyperclip
└── tkinter (GUI)

complete_automation_gui.py
├── llm.two_stage_processor
├── core.config
└── tkinter

two_stage_processor.py
├── llm.gemini_client
├── compose.email_sender_manager
└── loguru

client_discovery/
├── main_crawler.py
├── m2_list_scanner.py
└── config.json
```

---

## 🌐 **웹 자동화 모듈 (file_organizer 기반)**

### **🎯 핵심 클래스: FileOrganizerGUI**

```python
class FileOrganizerGUI:
    def __init__(self):
        # 폴더 경로 설정
        self.download_folder = Path("C:/Users/Administrator/Downloads")
        self.work_folder = Path("E:/업무")
        self.database_file = Path("E:/업무/03_데이터_수집/이커머스_수집_데이터베이스.xlsx")

        # 웹 자동화 상태
        self.automation_running = False
        self.automation_paused = False
        self.processed_count = 0
        self.failed_products = []
        self.total_products = 30

        # 중복 체크용 해시 딕셔너리
        self.file_hashes = {}

        # 순서 기반 매칭용 FIFO 큐
        self.pending_stores = []  # [(스토어명, 파일처리시간), ...]
```

### **🔄 메인 자동화 루프**

```python
def run_automation(self):
    """자동화 메인 루프"""
    self.automation_running = True
    self.automation_button.config(text="⏸️ 자동화 실행 중...", state="disabled")

    try:
        self.update_status("웹 자동화 시작 - 3초 후 시작합니다...")
        time.sleep(3)

        for i in range(self.total_products):
            if not self.automation_running:  # ESC로 중단된 경우
                break

            self.update_status(f"제품 {i+1}/{self.total_products} 처리 중...")

            success = self.process_single_product(i + 1)

            if success:
                self.processed_count += 1
            else:
                self.failed_products.append(i + 1)

            self.update_progress()

            # 다음 탭으로 이동 (마지막 제품이 아닌 경우만)
            if i < self.total_products - 1:
                pyautogui.hotkey('ctrl', 'w')  # 현재 탭 닫기
                time.sleep(1)

    except Exception as e:
        messagebox.showerror("오류", f"자동화 중 오류가 발생했습니다: {e}")

    finally:
        self.automation_complete()
```

### **🎮 단일 제품 처리 로직**

```python
def process_single_product(self, product_index):
    """단일 제품 처리"""
    try:
        # 1. URL 수집
        url = self.collect_current_url()
        if not url:
            return False

        # 2. 상세정보 펼쳐보기
        if not self.expand_product_details():
            return False

        # 3. 파이어샷 캡처
        if not self.capture_with_fireshot():
            return False

        # 4. 크롤링 시퀀스
        if not self.crawling_sequence():
            return False

        # 5. 데이터베이스 기록 (URL과 함께)
        self.record_product_url(url, product_index)

        return True

    except Exception as e:
        print(f"제품 {product_index} 처리 중 오류: {e}")
        return False
```

### **📋 URL 수집**

```python
def collect_current_url(self):
    """현재 탭의 URL 수집"""
    try:
        pyautogui.hotkey('ctrl', 'l')  # 주소창 선택
        time.sleep(0.5)
        pyautogui.hotkey('ctrl', 'c')  # URL 복사
        time.sleep(0.5)
        url = pyperclip.paste()
        print(f"URL 수집 완료: {url[:50]}...")
        return url
    except Exception as e:
        print(f"URL 수집 실패: {e}")
        return None
```

### **🔍 스마트 스크롤 버튼 찾기**

```python
def expand_product_details(self):
    """상세정보 펼쳐보기 (기존 로직 재사용)"""
    max_scrolls = 16
    scroll_amount = 800

    for scroll_count in range(max_scrolls):
        if not self.automation_running:  # 중단 확인
            return False

        try:
            location = pyautogui.locateOnScreen('detail_button.png', confidence=0.8)
            if location:
                center = pyautogui.center(location)
                pyautogui.click(center)
                print(f"상세정보 펼쳐보기 완료 (스크롤 {scroll_count + 1}회)")
                time.sleep(2)  # 페이지 로딩 대기
                return True
        except pyautogui.ImageNotFoundException:
            pass

        # 스크롤 다운
        pyautogui.scroll(-scroll_amount)
        time.sleep(0.5)

    print("상세정보 펼쳐보기 버튼을 찾지 못함")
    return False
```

### **📸 Fireshot 캡처**

```python
def capture_with_fireshot(self):
    """파이어샷으로 상세페이지 캡처"""
    try:
        # Fireshot 실행 (Ctrl+Shift+S)
        pyautogui.hotkey('ctrl', 'shift', 's')
        time.sleep(3)  # 캡처 완료 대기

        # 저장 버튼 클릭
        save_button = pyautogui.locateOnScreen('fireshot_save.png', confidence=0.8)
        if save_button:
            pyautogui.click(save_button)
            time.sleep(2)
            return True

        return False
    except Exception as e:
        print(f"Fireshot 캡처 실패: {e}")
        return False
```

### **🕸️ 크롤링 시퀀스 (4단계)**

```python
def crawling_sequence(self):
    """크롤링 시퀀스 실행"""
    try:
        # 1단계: 크롤링툴 실행 (Ctrl+Shift+A)
        pyautogui.hotkey('ctrl', 'shift', 'a')
        time.sleep(3)

        # 2단계: 크롤링 팝업에서 리뷰 버튼 클릭
        if not self.wait_for_button_with_context('review_button.png', 'popup_context.png'):
            return False

        # 3단계: 리뷰 화면에서 분석시작하기 클릭
        if not self.wait_for_button_with_context('analysis_start.png', 'review_context.png'):
            return False

        # 4단계: 분석 결과에서 엑셀 다운로드 클릭
        if not self.wait_for_button_with_context('excel_download.png', 'result_context.png', timeout=60):
            return False

        print("크롤링 시퀀스 완료")
        return True

    except Exception as e:
        print(f"크롤링 시퀀스 실패: {e}")
        return False
```

### **🎯 컨텍스트 기반 버튼 클릭**

```python
def wait_for_button_with_context(self, button_image, context_image, timeout=30):
    """컨텍스트를 확인한 후 버튼 클릭"""
    start_time = time.time()

    while time.time() - start_time < timeout:
        if not self.automation_running:  # 중단 확인
            return False

        try:
            # 컨텍스트 확인 (context_image가 None이면 건너뛰기)
            if context_image:
                context_location = pyautogui.locateOnScreen(context_image, confidence=0.7)
                if not context_location:
                    time.sleep(1)
                    continue

            # 버튼 찾기
            button_location = pyautogui.locateOnScreen(button_image, confidence=0.8)
            if button_location:
                center = pyautogui.center(button_location)
                pyautogui.click(center)
                print(f"버튼 클릭 성공: {button_image}")
                time.sleep(2)  # 클릭 후 대기
                return True

        except pyautogui.ImageNotFoundException:
            pass

        time.sleep(1)

    print(f"버튼 찾기 타임아웃: {button_image}")
    return False
```

### **🔄 재시도 로직**

```python
def click_button_with_retry(self, image_path, button_name, max_retries=3):
    """재시도 로직이 있는 버튼 클릭"""
    for attempt in range(max_retries):
        if not self.automation_running:
            return False

        try:
            location = pyautogui.locateOnScreen(image_path, confidence=0.8)
            if location:
                center = pyautogui.center(location)
                pyautogui.click(center)
                print(f"{button_name} 클릭 성공 (시도 {attempt + 1})")
                time.sleep(2)
                return True
        except pyautogui.ImageNotFoundException:
            print(f"{button_name} 찾기 실패 (시도 {attempt + 1})")
            time.sleep(2)

    return False
```

---

## 📁 **파일 정리 시스템**

### **🔍 파일명 파싱**

```python
def parse_filename(self, filename):
    """파일명을 분석하여 제품명, 브랜드명, 타입 추출"""
    # 파일명 패턴: "제품명_브랜드명_타입_날짜시간.확장자"

    try:
        name_without_ext = filename.rsplit('.', 1)[0]
        parts = name_without_ext.split('_')

        if len(parts) >= 4:
            product_name = parts[0]
            brand_name = parts[1]
            file_type = parts[2]
            timestamp = '_'.join(parts[3:])

            return {
                'product_name': product_name,
                'brand_name': brand_name,
                'file_type': file_type,
                'timestamp': timestamp,
                'original_filename': filename
            }
    except Exception as e:
        print(f"파일명 파싱 실패: {filename}, 오류: {e}")

    return None
```

### **🔄 순서 기반 매칭**

```python
def get_next_pending_store(self):
    """대기 중인 스토어 정보 반환 (FIFO)"""
    if self.pending_stores:
        return self.pending_stores.pop(0)  # 가장 오래된 것부터
    return None

def clean_old_pending_stores(self, cutoff_minutes=5):
    """오래된 대기 정보 정리"""
    cutoff_time = datetime.now() - timedelta(minutes=cutoff_minutes)
    self.pending_stores = [
        (store, timestamp) for store, timestamp in self.pending_stores
        if timestamp > cutoff_time
    ]
```

### **🔐 중복 파일 체크**

```python
def get_file_hash(self, file_path):
    """파일의 SHA-256 해시 계산"""
    hash_sha256 = hashlib.sha256()
    try:
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_sha256.update(chunk)
        return hash_sha256.hexdigest()
    except Exception as e:
        print(f"해시 계산 실패: {file_path}, 오류: {e}")
        return None

def check_duplicate(self, file_path):
    """중복 파일 체크"""
    file_hash = self.get_file_hash(file_path)
    if file_hash is None:
        return False

    if file_hash in self.file_hashes:
        print(f"중복 파일 발견: {file_path}")
        return True

    self.file_hashes[file_hash] = file_path
    return False
```

### **📊 엑셀 데이터베이스 관리**

```python
def create_excel_database(self):
    """이커머스 수집 데이터베이스 생성"""
    columns = [
        "수집일자", "제품명", "브랜드명", "스토어명", "URL",
        "상세페이지_파일경로", "리뷰데이터_파일경로", "처리상태", "비고"
    ]

    df = pd.DataFrame(columns=columns)
    df.to_excel(self.database_file, index=False, engine='openpyxl')
    print(f"데이터베이스 생성 완료: {self.database_file}")

def add_to_database(self, product_name, brand_name, email_address=""):
    """데이터베이스에 새 항목 추가"""
    try:
        # 기존 데이터 로드
        if self.database_file.exists():
            df = pd.read_excel(self.database_file, engine='openpyxl')
        else:
            self.create_excel_database()
            df = pd.read_excel(self.database_file, engine='openpyxl')

        # 새 행 추가
        new_row = {
            "수집일자": self.today,
            "제품명": product_name,
            "브랜드명": brand_name,
            "처리상태": "수집완료",
            "이메일주소": email_address
        }

        df = df.append(new_row, ignore_index=True)
        df.to_excel(self.database_file, index=False, engine='openpyxl')

    except Exception as e:
        print(f"데이터베이스 업데이트 실패: {e}")
```

---

## 🧠 **AI 처리 시스템**

### **🔬 TwoStageProcessor 클래스**

```python
class TwoStageProcessor:
    """2단계 분리 처리 시스템"""

    def __init__(self, config):
        self.config = config
        self.client = GeminiClient(config)

        # 발송 관리자 초기화
        try:
            self.email_manager = EmailSenderManager()
        except Exception as e:
            logger.warning(f"이메일 발송 관리자 초기화 실패: {e}")
            self.email_manager = None

    async def process_stage1_ocr(self, image_files: List[Path]) -> Dict[str, Any]:
        """Stage 1: OCR 및 데이터 추출"""
        logger.info(f"Stage 1 시작 - {len(image_files)}개 이미지 처리")

        ocr_results = {}

        for image_file in image_files:
            try:
                # Tesseract OCR 실행
                ocr_text = self.extract_text_from_image(image_file)

                # OCR 후처리
                cleaned_text = self.clean_ocr_text(ocr_text)

                # 구조화
                structured_data = await self.structure_product_data(cleaned_text)

                ocr_results[str(image_file)] = {
                    'raw_text': ocr_text,
                    'cleaned_text': cleaned_text,
                    'structured_data': structured_data
                }

            except Exception as e:
                logger.error(f"OCR 처리 실패 - {image_file}: {e}")
                continue

        return ocr_results

    async def process_stage2_email(self, stage1_results: Dict, review_files: List[Path]) -> List[Dict]:
        """Stage 2: 콜드메일 생성"""
        logger.info("Stage 2 시작 - 콜드메일 생성")

        generated_emails = []

        for image_path, ocr_data in stage1_results.items():
            for review_file in review_files:
                try:
                    # 리뷰 데이터 분석
                    review_analysis = self.analyze_review_data(review_file)

                    # 콜드메일 생성
                    email_content = await self.generate_cold_email(
                        ocr_data['structured_data'],
                        review_analysis
                    )

                    # 발송 관리자에 등록
                    if self.email_manager:
                        self.email_manager.add_to_pending_list(email_content)

                    generated_emails.append(email_content)

                except Exception as e:
                    logger.error(f"콜드메일 생성 실패: {e}")
                    continue

        return generated_emails
```

### **🔍 OCR 엔진 (Tesseract)**

```python
def extract_text_from_image(self, image_path: Path) -> str:
    """Tesseract를 사용한 OCR 텍스트 추출"""
    try:
        import pytesseract
        from PIL import Image

        # 이미지 로드 및 전처리
        image = Image.open(image_path)

        # OCR 설정
        custom_config = r'--oem 3 --psm 6 -l kor+eng'

        # OCR 실행
        text = pytesseract.image_to_string(image, config=custom_config)

        return text

    except ImportError:
        logger.warning("Tesseract가 설치되지 않음 - 더미 텍스트 반환")
        return f"더미 OCR 텍스트: {image_path.name}"
    except Exception as e:
        logger.error(f"OCR 실행 실패: {e}")
        return ""

def clean_ocr_text(self, raw_text: str) -> str:
    """OCR 텍스트 후처리"""
    # 불필요한 문자 제거
    cleaned = re.sub(r'[^\w\s가-힣]', ' ', raw_text)

    # 중복 공백 제거
    cleaned = re.sub(r'\s+', ' ', cleaned)

    # 가격 정보 정규화
    cleaned = re.sub(r'(\d+)원', r'\1 원', cleaned)

    return cleaned.strip()
```

### **🎯 Gemini 클라이언트**

```python
class GeminiClient:
    def __init__(self, config):
        self.config = config
        self.model = genai.GenerativeModel(config.llm.model_name)

        # 안전장치 초기화
        self.budget_guard = BudgetGuard(config.budget.max_cost_per_job_usd)
        self.rate_limiter = RateLimiter(
            config.runtime.rate_limit['rpm_soft'],
            config.runtime.rate_limit['tpm_soft']
        )

    async def generate(self, prompt_template: Dict, user_input: str) -> Dict:
        """AI 콜드메일 생성"""
        try:
            # 비용 체크
            if not self.budget_guard.can_proceed():
                raise Exception("예산 한도 초과")

            # 레이트 리미팅
            await self.rate_limiter.wait_if_needed()

            # 프롬프트 조립
            full_prompt = self.build_prompt(prompt_template, user_input)

            # AI 호출
            response = await self.model.generate_content_async(full_prompt)

            # 비용 업데이트
            self.budget_guard.add_cost(self.estimate_cost(response))

            # JSON 파싱
            result = json.loads(response.text)

            return result

        except Exception as e:
            logger.error(f"AI 생성 실패: {e}")
            raise
```

### **💰 비용 관리**

```python
class BudgetGuard:
    def __init__(self, max_cost_usd: float):
        self.max_cost = max_cost_usd
        self.current_cost = 0.0

    def can_proceed(self) -> bool:
        return self.current_cost < self.max_cost

    def add_cost(self, cost: float):
        self.current_cost += cost
        if self.current_cost >= self.max_cost * 0.9:  # 90% 도달 시 경고
            logger.warning(f"예산 90% 사용: ${self.current_cost:.2f} / ${self.max_cost:.2f}")

class RateLimiter:
    def __init__(self, rpm_limit: int, tpm_limit: int):
        self.rpm_limit = rpm_limit
        self.tpm_limit = tpm_limit
        self.request_times = []
        self.token_usage = []

    async def wait_if_needed(self):
        current_time = time.time()

        # 1분 이내 요청 수 체크
        recent_requests = [t for t in self.request_times if current_time - t < 60]

        if len(recent_requests) >= self.rpm_limit:
            wait_time = 60 - (current_time - recent_requests[0])
            await asyncio.sleep(wait_time)

        self.request_times.append(current_time)
```

---

## 📧 **콜드메일 발송 관리 시스템**

### **📋 EmailSenderManager 클래스**

```python
class EmailSenderManager:
    """콜드메일 발송 관리 시스템"""

    def __init__(self):
        # 경로 설정
        self.work_folder = Path("E:/업무")
        self.database_file = Path("E:/업무/03_데이터_수집/이커머스_수집_데이터베이스.xlsx")
        self.coldmail_folder = Path("E:/업무/4.콜드메일_관리")
        self.pending_folder = self.coldmail_folder / "발송대기"
        self.sent_folder = self.coldmail_folder / "발송완료"
        self.pending_excel = self.pending_folder / "콜드메일_발송대기_리스트.xlsx"

        # 폴더 생성
        self.pending_folder.mkdir(parents=True, exist_ok=True)
        self.sent_folder.mkdir(parents=True, exist_ok=True)

        # 발송대기 엑셀 초기화
        self.init_pending_excel()

    def init_pending_excel(self):
        """발송대기 엑셀 파일 초기화"""
        if not self.pending_excel.exists():
            columns = [
                "생성일시", "제품명", "브랜드명", "스토어명", "콜드메일_파일경로",
                "발송상태", "발송예정일", "담당자", "비고"
            ]
            df = pd.DataFrame(columns=columns)
            df.to_excel(self.pending_excel, index=False, engine='openpyxl')

    def add_to_pending_list(self, email_data: Dict):
        """발송대기 리스트에 추가"""
        try:
            # 콜드메일 파일 저장
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            email_filename = f"콜드메일_{email_data.get('제품명', 'unknown')}_{timestamp}.json"
            email_filepath = self.pending_folder / email_filename

            with open(email_filepath, 'w', encoding='utf-8') as f:
                json.dump(email_data, f, ensure_ascii=False, indent=2)

            # 발송대기 엑셀 업데이트
            df = pd.read_excel(self.pending_excel, engine='openpyxl')

            new_row = {
                "생성일시": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "제품명": email_data.get('제품명', ''),
                "브랜드명": email_data.get('브랜드명', ''),
                "스토어명": email_data.get('스토어명', ''),
                "콜드메일_파일경로": str(email_filepath),
                "발송상태": "대기",
                "발송예정일": (datetime.now() + timedelta(days=1)).strftime("%Y-%m-%d"),
                "담당자": "",
                "비고": "자동생성"
            }

            df = df.append(new_row, ignore_index=True)
            df.to_excel(self.pending_excel, index=False, engine='openpyxl')

            logger.info(f"발송대기 리스트에 추가됨: {email_filename}")

        except Exception as e:
            logger.error(f"발송대기 리스트 추가 실패: {e}")
```

---

## 🎮 **GUI 시스템들**

### **🎯 통합 자동화 GUI (ultimate_automation_system.py)**

```python
class UltimateAutomationSystem:
    """궁극의 통합 자동화 시스템"""

    def __init__(self):
        self.root = tk.Tk()
        self.root.title("궁극의 이커머스 콜드메일 자동화 시스템 - 완전통합")
        self.root.geometry("1800x1200")

        # 상태 변수들
        self.automation_running = False
        self.is_ai_processing = False
        self.generated_emails = []

        # 설정 값들
        self.total_products = 30
        self.tone_var = tk.StringVar(value="consultant")
        self.min_chars = tk.IntVar(value=350)
        self.max_chars = tk.IntVar(value=600)

        self.create_widgets()
        self.setup_hotkeys()

    def create_widgets(self):
        """통합 GUI 위젯 생성"""
        # 메인 제목
        title_frame = tk.Frame(self.root, bg="#1a252f", height=80)
        title_frame.pack(fill="x", padx=5, pady=5)

        # 메인 컨트롤 패널
        self.create_main_control_panel()

        # 탭 시스템
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill="both", expand=True, padx=10, pady=5)

        # 각 탭 생성
        self.create_automation_tab()      # 자동화 현황
        self.create_web_automation_tab()  # 웹 자동화
        self.create_ai_generation_tab()   # AI 콜드메일
        self.create_client_discovery_tab() # 고객사 발굴
        self.create_results_tab()         # 결과 보기
        self.create_settings_tab()        # 설정

    def start_complete_automation(self):
        """완전 자동화 시작 - 메인 기능"""
        if self.automation_running:
            messagebox.showwarning("경고", "이미 자동화가 실행 중입니다.")
            return

        # 사전 체크
        if not self.pre_automation_check():
            return

        # 확인 대화상자
        total_products = self.total_products_var.get()
        response = messagebox.askyesno(
            "완전 자동화 시작",
            f"완전 자동화를 시작하시겠습니까?\n\n"
            f"🎯 처리할 제품: {total_products}개\n"
            f"⏰ 예상 소요시간: 2-3시간\n"
            f"📧 예상 생성물: {total_products}개 콜드메일\n"
        )

        if response:
            self.automation_running = True
            threading.Thread(target=self.complete_automation_thread, daemon=True).start()
```

### **🔄 2단계 GUI (two_stage_gui.py)**

```python
class TwoStageGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("🎯 AI 콜드메일 2단계 분리 처리 시스템")
        self.root.geometry("1000x700")

        # 2단계 처리기 초기화
        config = load_config()
        self.processor = TwoStageProcessor(config)

        # GUI 요소들
        self.create_stage1_tab()
        self.create_stage2_tab()
        self.create_settings_tab()

    def create_stage1_tab(self):
        """Stage 1: OCR 및 데이터 추출 탭"""
        stage1_frame = ttk.Frame(self.notebook)
        self.notebook.add(stage1_frame, text="Stage 1: OCR")

        # 이미지 파일 선택
        file_select_frame = tk.LabelFrame(stage1_frame, text="이미지 파일 선택")
        file_select_frame.pack(fill="x", padx=10, pady=5)

        tk.Button(file_select_frame, text="이미지 폴더 선택",
                 command=self.select_image_folder).pack(side="left", padx=5)

        # OCR 실행 버튼
        ocr_frame = tk.LabelFrame(stage1_frame, text="OCR 실행")
        ocr_frame.pack(fill="x", padx=10, pady=5)

        tk.Button(ocr_frame, text="Stage 1 실행 (OCR + 구조화)",
                 command=self.run_stage1).pack(pady=10)

    def run_stage1(self):
        """Stage 1 실행"""
        def stage1_thread():
            try:
                self.update_status("Stage 1 실행 중...")

                # 이미지 파일 목록 가져오기
                image_files = self.get_selected_images()

                # 비동기 OCR 처리
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)

                results = loop.run_until_complete(
                    self.processor.process_stage1_ocr(image_files)
                )

                loop.close()

                # 결과 저장
                self.stage1_results = results
                self.update_status(f"Stage 1 완료: {len(results)}개 이미지 처리됨")

            except Exception as e:
                messagebox.showerror("오류", f"Stage 1 실행 실패: {e}")

        threading.Thread(target=stage1_thread, daemon=True).start()
```

---

## 🔍 **고객사 발굴 시스템**

### **🕸️ NaverShoppingCrawler 클래스**

```python
class NaverShoppingCrawler:
    def __init__(self, config_path: str):
        with open(config_path, 'r', encoding='utf-8') as f:
            self.config = json.load(f)

        self.driver = None
        self.results = []

    def start_crawling(self) -> List[Dict]:
        """크롤링 시작"""
        try:
            self.setup_driver()

            # 현재 페이지에서 스토어 카드들 스캔
            store_cards = self.scan_current_page()

            # 필터링 적용
            filtered_stores = self.apply_filters(store_cards)

            # 결과 저장
            self.save_results(filtered_stores)

            return filtered_stores

        except Exception as e:
            logger.error(f"크롤링 실패: {e}")
            return []
        finally:
            if self.driver:
                self.driver.quit()

    def scan_current_page(self) -> List[Dict]:
        """현재 페이지의 스토어 카드들 스캔"""
        store_cards = []

        try:
            # 페이지의 모든 상품 카드 찾기
            product_elements = self.driver.find_elements(
                By.CSS_SELECTOR, ".product_item, .item_area"
            )

            for element in product_elements:
                try:
                    store_info = self.extract_store_info(element)
                    if store_info:
                        store_cards.append(store_info)
                except Exception as e:
                    logger.warning(f"카드 정보 추출 실패: {e}")
                    continue

        except Exception as e:
            logger.error(f"페이지 스캔 실패: {e}")

        return store_cards

    def extract_store_info(self, element) -> Dict:
        """개별 스토어 정보 추출"""
        try:
            # OCR을 사용한 텍스트 추출
            screenshot = element.screenshot_as_png

            # pytesseract로 텍스트 추출
            text = pytesseract.image_to_string(
                Image.open(io.BytesIO(screenshot)),
                lang='kor+eng'
            )

            # 정규식으로 정보 추출
            review_count = self.extract_review_count(text)
            follower_count = self.extract_follower_count(text)

            return {
                'store_name': self.extract_store_name(text),
                'product_name': self.extract_product_name(text),
                'review_count': review_count,
                'follower_count': follower_count,
                'price': self.extract_price(text),
                'rating': self.extract_rating(text),
                'link': element.find_element(By.TAG_NAME, "a").get_attribute("href")
            }

        except Exception as e:
            logger.error(f"스토어 정보 추출 실패: {e}")
            return None
```

---

## 🚀 **실행 및 빌드 시스템**

### **📦 PyInstaller 빌드 스크립트**

```python
# complete_automation.spec
# -*- mode: python ; coding: utf-8 -*-

block_cipher = None

a = Analysis(
    ['ultimate_automation_system.py'],
    pathex=['E:\\VSC\\all_in_one\\all_in_one_new\\all_in_one'],
    binaries=[],
    datas=[
        ('config', 'config'),
        ('llm/prompts', 'llm/prompts'),
        ('gui', 'gui'),
        ('compose', 'compose'),
        ('client_discovery', 'client_discovery'),
        ('data', 'data'),
    ],
    hiddenimports=[
        'google.generativeai',
        'pytesseract',
        'openpyxl',
        'pandas',
        'pyautogui',
        'pyperclip',
        'loguru',
        'PIL',
    ],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyd = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyd,
    a.scripts,
    [],
    exclude_binaries=True,
    name='CompleteAutomation',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console=False,  # GUI 모드
    disable_windowed_traceback=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon='assets/icon.ico'  # 아이콘 설정
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name='CompleteAutomation'
)
```

### **🛠️ 환경 설정 스크립트**

```bash
# setup_env_vars.bat
@echo off
echo ====== 환경 변수 설정 ======

:: Google AI Studio 프로젝트 ID 설정
set VERTEX_PROJECT_ID=jadong-471919
echo VERTEX_PROJECT_ID 설정 완료: %VERTEX_PROJECT_ID%

:: 환경 변수 영구 저장
setx VERTEX_PROJECT_ID "%VERTEX_PROJECT_ID%"

:: Tesseract 경로 확인
if exist "E:\tesseract\tesseract.exe" (
    echo Tesseract 설치 확인됨
    set TESSDATA_PREFIX=E:\tesseract\tessdata
    setx TESSDATA_PREFIX "%TESSDATA_PREFIX%"
) else (
    echo [WARNING] Tesseract가 설치되지 않았습니다
    echo 다운로드: https://github.com/UB-Mannheim/tesseract/wiki
)

:: Python 패키지 설치
echo Python 패키지 설치 중...
pip install -r requirements.txt

echo ====== 설정 완료 ======
pause
```

### **📋 요구사항 파일**

```text
# requirements.txt
google-generativeai>=0.3.0
pytesseract>=0.3.10
Pillow>=9.0.0
pandas>=1.5.0
openpyxl>=3.1.0
pyautogui>=0.9.54
pyperclip>=1.8.2
loguru>=0.7.0
selenium>=4.15.0
beautifulsoup4>=4.12.0
requests>=2.31.0
tkinter  # 표준 라이브러리이지만 명시
pathlib  # 표준 라이브러리
json     # 표준 라이브러리
threading # 표준 라이브러리
asyncio  # 표준 라이브러리
```

---

## 🔧 **설정 파일들**

### **⚙️ config.yaml**

```yaml
# config/config.yaml
llm:
  model_name: "gemini-1.5-pro"
  temperature: 0.3
  max_tokens: 2048

paths:
  input_images_dir: "data/product_images"
  input_reviews_dir: "data/reviews"
  output_root_dir: "outputs"
  prompts_dir: "llm/prompts"

budget:
  max_cost_per_job_usd: 10.0

runtime:
  rate_limit:
    rpm_soft: 30
    tpm_soft: 50000

policy:
  email_min_chars: 350
  email_max_chars: 600
  tone_default: "consultant"

file_organizer:
  download_folder: "C:/Users/Administrator/Downloads"
  work_folder: "E:/업무"
  database_file: "E:/업무/03_데이터_수집/이커머스_수집_데이터베이스.xlsx"
  max_scrolls: 16
  scroll_amount: 800
  button_confidence: 0.8
  context_confidence: 0.7
```

### **🎯 고객사 발굴 설정**

```json
// client_discovery/config.json
{
  "selenium": {
    "driver_path": "chromedriver.exe",
    "headless": false,
    "window_size": [1920, 1080],
    "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
  },
  "crawling": {
    "max_products_per_page": 40,
    "scroll_delay": 2,
    "element_wait_timeout": 10
  },
  "filters": {
    "review_count_min": 200,
    "review_count_max": 300,
    "follower_count_min": 50,
    "follower_count_max": 1500
  },
  "ocr": {
    "lang": "kor+eng",
    "config": "--oem 3 --psm 6"
  },
  "output": {
    "format": "csv",
    "encoding": "utf-8-sig"
  }
}
```

---

## 🛡️ **에러 처리 및 로깅**

### **📊 로깅 시스템**

```python
# core/logger.py
from loguru import logger
import sys
from pathlib import Path

def setup_logger(job_id: str, output_dir: str):
    """작업별 로거 설정"""

    # 기존 핸들러 제거
    logger.remove()

    # 콘솔 출력
    logger.add(
        sys.stdout,
        format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
        level="INFO"
    )

    # 파일 출력
    log_file = Path(output_dir) / f"{job_id}_automation.log"
    logger.add(
        log_file,
        format="{time:YYYY-MM-DD HH:mm:ss} | {level: <8} | {name}:{function}:{line} - {message}",
        level="DEBUG",
        rotation="10 MB",
        retention="30 days",
        encoding="utf-8"
    )

    return logger
```

### **🔒 안전장치 시스템**

```python
# core/safety_monitor.py
class SafetyMonitor:
    def __init__(self):
        self.start_time = time.time()
        self.max_runtime_hours = 6  # 최대 6시간 실행
        self.memory_threshold_mb = 2048  # 2GB 메모리 제한

    def check_runtime_limit(self):
        """실행 시간 제한 체크"""
        elapsed_hours = (time.time() - self.start_time) / 3600
        if elapsed_hours > self.max_runtime_hours:
            raise RuntimeError(f"최대 실행 시간 초과: {elapsed_hours:.1f}시간")

    def check_memory_usage(self):
        """메모리 사용량 체크"""
        import psutil
        process = psutil.Process()
        memory_mb = process.memory_info().rss / 1024 / 1024

        if memory_mb > self.memory_threshold_mb:
            logger.warning(f"높은 메모리 사용량: {memory_mb:.1f}MB")

        return memory_mb

    def emergency_stop_check(self):
        """긴급 중단 체크"""
        # ESC 키 체크, 파일 기반 중단 신호 등
        stop_file = Path("EMERGENCY_STOP")
        if stop_file.exists():
            stop_file.unlink()  # 파일 삭제
            raise KeyboardInterrupt("긴급 중단 신호 감지")
```

---

## 🎯 **완료! 완전한 기술 명세서 백업 완료**

이제 모든 기술적 세부사항이 완전히 백업되었습니다. 이 문서들을 기반으로 100% 정확한 복원이 가능합니다!